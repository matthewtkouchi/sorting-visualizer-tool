{"ast":null,"code":"/*let globalSnapshot = [];\r\nlet globalArr = [];\r\n\r\nconst mergeSort = (arr) => {\r\n  const midpoint = arr.length / 2;\r\n  globalSnapshot = [[...arr]];\r\n  globalArr = arr;\r\n\r\n  // Base case\r\n  if (globalArr.length < 2) {\r\n    return arr;\r\n  }\r\n\r\n  const splitArr = arr.splice(0, midpoint);\r\n  merge(mergeSort(splitArr), mergeSort(globalArr));\r\n\r\n  return globalSnapshot;\r\n};\r\n\r\nconst merge = (left, right) => {\r\n  let arr = [];\r\n  // Break out of loop if any one of the array gets empty\r\n  while (left.length && right.length) {\r\n    // Pick the smaller among the smallest element of left and right sub arrays\r\n    if (left[0] < right[0]) {\r\n      arr.push(left.shift());\r\n      globalSnapshot.push([...arr]);\r\n    } else {\r\n      arr.push(right.shift());\r\n      globalSnapshot.push([...arr]);\r\n    }\r\n  }\r\n\r\n  // Concatenating the leftover elements\r\n  // (in case we didn't go through the entire left or right array)\r\n  return [...arr, ...left, ...right];\r\n}; */\nconst mergeSortHelper = a => {\n  if (a.length < 2) return a;\n  const middle = Math.floor(a.length / 2);\n  const a_l = a.slice(0, middle);\n  const a_r = a.slice(middle, a.length);\n  const sorted_l = mergeSortHelper(a_l);\n  const sorted_r = mergeSortHelper(a_r);\n  return mergeArrays(sorted_l, sorted_r);\n};\n\nconst mergeArrays = (a, b) => {\n  const c = [];\n\n  while (a.length && b.length) {\n    c.push(a[0] > b[0] ? b.shift() : a.shift());\n  } //if we still have values, let's add them at the end of `c`\n\n\n  while (a.length) {\n    c.push(a.shift());\n  }\n\n  while (b.length) {\n    c.push(b.shift());\n  }\n\n  return c;\n};\n\nexport default mergeSort;","map":{"version":3,"sources":["C:/Users/mkouc/OneDrive/Desktop/sorting_visualizer/src/scripts/algorithms/mergeSort.js"],"names":["mergeSortHelper","a","length","middle","Math","floor","a_l","slice","a_r","sorted_l","sorted_r","mergeArrays","b","c","push","shift","mergeSort"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,eAAe,GAAIC,CAAD,IAAO;AAC7B,MAAIA,CAAC,CAACC,MAAF,GAAW,CAAf,EAAkB,OAAOD,CAAP;AAClB,QAAME,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWJ,CAAC,CAACC,MAAF,GAAW,CAAtB,CAAf;AACA,QAAMI,GAAG,GAAGL,CAAC,CAACM,KAAF,CAAQ,CAAR,EAAWJ,MAAX,CAAZ;AACA,QAAMK,GAAG,GAAGP,CAAC,CAACM,KAAF,CAAQJ,MAAR,EAAgBF,CAAC,CAACC,MAAlB,CAAZ;AACA,QAAMO,QAAQ,GAAGT,eAAe,CAACM,GAAD,CAAhC;AACA,QAAMI,QAAQ,GAAGV,eAAe,CAACQ,GAAD,CAAhC;AACA,SAAOG,WAAW,CAACF,QAAD,EAAWC,QAAX,CAAlB;AACD,CARD;;AAUA,MAAMC,WAAW,GAAG,CAACV,CAAD,EAAIW,CAAJ,KAAU;AAC5B,QAAMC,CAAC,GAAG,EAAV;;AAEA,SAAOZ,CAAC,CAACC,MAAF,IAAYU,CAAC,CAACV,MAArB,EAA6B;AAC3BW,IAAAA,CAAC,CAACC,IAAF,CAAOb,CAAC,CAAC,CAAD,CAAD,GAAOW,CAAC,CAAC,CAAD,CAAR,GAAcA,CAAC,CAACG,KAAF,EAAd,GAA0Bd,CAAC,CAACc,KAAF,EAAjC;AACD,GAL2B,CAO5B;;;AACA,SAAOd,CAAC,CAACC,MAAT,EAAiB;AACfW,IAAAA,CAAC,CAACC,IAAF,CAAOb,CAAC,CAACc,KAAF,EAAP;AACD;;AACD,SAAOH,CAAC,CAACV,MAAT,EAAiB;AACfW,IAAAA,CAAC,CAACC,IAAF,CAAOF,CAAC,CAACG,KAAF,EAAP;AACD;;AAED,SAAOF,CAAP;AACD,CAhBD;;AAkBA,eAAeG,SAAf","sourcesContent":["/*let globalSnapshot = [];\r\nlet globalArr = [];\r\n\r\nconst mergeSort = (arr) => {\r\n  const midpoint = arr.length / 2;\r\n  globalSnapshot = [[...arr]];\r\n  globalArr = arr;\r\n\r\n  // Base case\r\n  if (globalArr.length < 2) {\r\n    return arr;\r\n  }\r\n\r\n  const splitArr = arr.splice(0, midpoint);\r\n  merge(mergeSort(splitArr), mergeSort(globalArr));\r\n\r\n  return globalSnapshot;\r\n};\r\n\r\nconst merge = (left, right) => {\r\n  let arr = [];\r\n  // Break out of loop if any one of the array gets empty\r\n  while (left.length && right.length) {\r\n    // Pick the smaller among the smallest element of left and right sub arrays\r\n    if (left[0] < right[0]) {\r\n      arr.push(left.shift());\r\n      globalSnapshot.push([...arr]);\r\n    } else {\r\n      arr.push(right.shift());\r\n      globalSnapshot.push([...arr]);\r\n    }\r\n  }\r\n\r\n  // Concatenating the leftover elements\r\n  // (in case we didn't go through the entire left or right array)\r\n  return [...arr, ...left, ...right];\r\n}; */\r\n\r\nconst mergeSortHelper = (a) => {\r\n  if (a.length < 2) return a;\r\n  const middle = Math.floor(a.length / 2);\r\n  const a_l = a.slice(0, middle);\r\n  const a_r = a.slice(middle, a.length);\r\n  const sorted_l = mergeSortHelper(a_l);\r\n  const sorted_r = mergeSortHelper(a_r);\r\n  return mergeArrays(sorted_l, sorted_r);\r\n};\r\n\r\nconst mergeArrays = (a, b) => {\r\n  const c = [];\r\n\r\n  while (a.length && b.length) {\r\n    c.push(a[0] > b[0] ? b.shift() : a.shift());\r\n  }\r\n\r\n  //if we still have values, let's add them at the end of `c`\r\n  while (a.length) {\r\n    c.push(a.shift());\r\n  }\r\n  while (b.length) {\r\n    c.push(b.shift());\r\n  }\r\n\r\n  return c;\r\n};\r\n\r\nexport default mergeSort;\r\n"]},"metadata":{},"sourceType":"module"}