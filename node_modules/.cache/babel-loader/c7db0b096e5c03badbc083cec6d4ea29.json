{"ast":null,"code":"// const globalSnapshot = [];\n// const mergeSort = (arr) => {\n//   mergeSortHelper(arr);\n//   return globalSnapshot;\n// };\n// const mergeSortHelper = (a) => {\n//   if (a.length < 2) return a;\n//   const middle = Math.floor(a.length / 2);\n//   const a_l = a.slice(0, middle);\n//   const a_r = a.slice(middle, a.length);\n//   const sorted_l = mergeSortHelper(a_l);\n//   const sorted_r = mergeSortHelper(a_r);\n//   return mergeArrays(sorted_l, sorted_r);\n// };\n// const mergeArrays = (a, b) => {\n//   const c = [];\n//   while (a.length && b.length) {\n//     c.push(a[0] > b[0] ? b.shift() : a.shift());\n//   }\n//   //if we still have values, let's add them at the end of `c`\n//   while (a.length) {\n//     c.push(a.shift());\n//   }\n//   while (b.length) {\n//     c.push(b.shift());\n//   }\n//   return c;\n// };\nlet globalSnapshot = [];\n\nconst mergeSort = arr => {\n  globalSnapshot = [[...arr]];\n  let size = 1;\n  const len = arr.length;\n\n  do {\n    let i = 0;\n\n    do {\n      const L1 = i;\n      const R1 = i + size - 1;\n      const L2 = i + size;\n      let R2 = i + 2 * size - 1;\n      if (L2 >= len) break;\n      if (R2 >= len) R2 = len - 1;\n      const temp = mergeArray(arr, L1, R1, L2, R2);\n      let j = 0;\n\n      do {\n        arr[i + j] = temp[j];\n        globalSnapshot.push([...arr]);\n        j++;\n      } while (j <= R2 - L1 + 1);\n\n      i = i + 2 * size;\n    } while (i < len);\n\n    size = 2 * size;\n  } while (size < len);\n\n  globalSnapshot = [[arr]];\n  return globalSnapshot;\n};\n\nconst mergeArray = (arr, L1, R1, L2, R2) => {\n  let temp = [];\n  let i = 0; // While Both Sub-Arrays Can Be Spliced\n\n  do {\n    if (arr[L1] <= arr[L2]) {\n      temp[i] = arr[L1];\n      i++;\n      L1++;\n    } else {\n      temp[i] = arr[L2];\n      i++;\n      L2++;\n    }\n  } while (L1 <= R1 && L2 <= R2); // While Left Sub-Arrays Can Be Spliced\n\n\n  do {\n    temp[i] = arr[L1];\n    i++;\n    L1++;\n  } while (L1 <= R1); // While Right Sub-Arrays Can Be Spliced\n\n\n  do {\n    temp[i] = arr[L2];\n    i++;\n    L2++;\n  } while (L2 <= R2);\n\n  return temp;\n};\n\nexport default mergeSort;","map":{"version":3,"sources":["C:/Users/mkouc/OneDrive/Desktop/sorting_visualizer/src/scripts/algorithms/mergeSort.js"],"names":["globalSnapshot","mergeSort","arr","size","len","length","i","L1","R1","L2","R2","temp","mergeArray","j","push"],"mappings":"AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA,IAAIA,cAAc,GAAG,EAArB;;AAEA,MAAMC,SAAS,GAAIC,GAAD,IAAS;AACzBF,EAAAA,cAAc,GAAG,CAAC,CAAC,GAAGE,GAAJ,CAAD,CAAjB;AACA,MAAIC,IAAI,GAAG,CAAX;AACA,QAAMC,GAAG,GAAGF,GAAG,CAACG,MAAhB;;AACA,KAAG;AACD,QAAIC,CAAC,GAAG,CAAR;;AACA,OAAG;AACD,YAAMC,EAAE,GAAGD,CAAX;AACA,YAAME,EAAE,GAAGF,CAAC,GAAGH,IAAJ,GAAW,CAAtB;AACA,YAAMM,EAAE,GAAGH,CAAC,GAAGH,IAAf;AACA,UAAIO,EAAE,GAAGJ,CAAC,GAAG,IAAIH,IAAR,GAAe,CAAxB;AACA,UAAIM,EAAE,IAAIL,GAAV,EAAe;AACf,UAAIM,EAAE,IAAIN,GAAV,EAAeM,EAAE,GAAGN,GAAG,GAAG,CAAX;AACf,YAAMO,IAAI,GAAGC,UAAU,CAACV,GAAD,EAAMK,EAAN,EAAUC,EAAV,EAAcC,EAAd,EAAkBC,EAAlB,CAAvB;AACA,UAAIG,CAAC,GAAG,CAAR;;AACA,SAAG;AACDX,QAAAA,GAAG,CAACI,CAAC,GAAGO,CAAL,CAAH,GAAaF,IAAI,CAACE,CAAD,CAAjB;AACAb,QAAAA,cAAc,CAACc,IAAf,CAAoB,CAAC,GAAGZ,GAAJ,CAApB;AACAW,QAAAA,CAAC;AACF,OAJD,QAISA,CAAC,IAAIH,EAAE,GAAGH,EAAL,GAAU,CAJxB;;AAKAD,MAAAA,CAAC,GAAGA,CAAC,GAAG,IAAIH,IAAZ;AACD,KAfD,QAeSG,CAAC,GAAGF,GAfb;;AAgBAD,IAAAA,IAAI,GAAG,IAAIA,IAAX;AACD,GAnBD,QAmBSA,IAAI,GAAGC,GAnBhB;;AAoBAJ,EAAAA,cAAc,GAAG,CAAC,CAACE,GAAD,CAAD,CAAjB;AACA,SAAOF,cAAP;AACD,CA1BD;;AA4BA,MAAMY,UAAU,GAAG,CAACV,GAAD,EAAMK,EAAN,EAAUC,EAAV,EAAcC,EAAd,EAAkBC,EAAlB,KAAyB;AAC1C,MAAIC,IAAI,GAAG,EAAX;AACA,MAAIL,CAAC,GAAG,CAAR,CAF0C,CAG1C;;AACA,KAAG;AACD,QAAIJ,GAAG,CAACK,EAAD,CAAH,IAAWL,GAAG,CAACO,EAAD,CAAlB,EAAwB;AACtBE,MAAAA,IAAI,CAACL,CAAD,CAAJ,GAAUJ,GAAG,CAACK,EAAD,CAAb;AACAD,MAAAA,CAAC;AACDC,MAAAA,EAAE;AACH,KAJD,MAIO;AACLI,MAAAA,IAAI,CAACL,CAAD,CAAJ,GAAUJ,GAAG,CAACO,EAAD,CAAb;AACAH,MAAAA,CAAC;AACDG,MAAAA,EAAE;AACH;AACF,GAVD,QAUSF,EAAE,IAAIC,EAAN,IAAYC,EAAE,IAAIC,EAV3B,EAJ0C,CAgB1C;;;AACA,KAAG;AACDC,IAAAA,IAAI,CAACL,CAAD,CAAJ,GAAUJ,GAAG,CAACK,EAAD,CAAb;AACAD,IAAAA,CAAC;AACDC,IAAAA,EAAE;AACH,GAJD,QAISA,EAAE,IAAIC,EAJf,EAjB0C,CAuB1C;;;AACA,KAAG;AACDG,IAAAA,IAAI,CAACL,CAAD,CAAJ,GAAUJ,GAAG,CAACO,EAAD,CAAb;AACAH,IAAAA,CAAC;AACDG,IAAAA,EAAE;AACH,GAJD,QAISA,EAAE,IAAIC,EAJf;;AAMA,SAAOC,IAAP;AACD,CA/BD;;AAiCA,eAAeV,SAAf","sourcesContent":["// const globalSnapshot = [];\r\n\r\n// const mergeSort = (arr) => {\r\n//   mergeSortHelper(arr);\r\n\r\n//   return globalSnapshot;\r\n// };\r\n\r\n// const mergeSortHelper = (a) => {\r\n//   if (a.length < 2) return a;\r\n//   const middle = Math.floor(a.length / 2);\r\n//   const a_l = a.slice(0, middle);\r\n//   const a_r = a.slice(middle, a.length);\r\n//   const sorted_l = mergeSortHelper(a_l);\r\n//   const sorted_r = mergeSortHelper(a_r);\r\n//   return mergeArrays(sorted_l, sorted_r);\r\n// };\r\n\r\n// const mergeArrays = (a, b) => {\r\n//   const c = [];\r\n\r\n//   while (a.length && b.length) {\r\n//     c.push(a[0] > b[0] ? b.shift() : a.shift());\r\n\r\n//   }\r\n\r\n//   //if we still have values, let's add them at the end of `c`\r\n//   while (a.length) {\r\n//     c.push(a.shift());\r\n//   }\r\n//   while (b.length) {\r\n//     c.push(b.shift());\r\n//   }\r\n\r\n//   return c;\r\n// };\r\n\r\nlet globalSnapshot = [];\r\n\r\nconst mergeSort = (arr) => {\r\n  globalSnapshot = [[...arr]];\r\n  let size = 1;\r\n  const len = arr.length;\r\n  do {\r\n    let i = 0;\r\n    do {\r\n      const L1 = i;\r\n      const R1 = i + size - 1;\r\n      const L2 = i + size;\r\n      let R2 = i + 2 * size - 1;\r\n      if (L2 >= len) break;\r\n      if (R2 >= len) R2 = len - 1;\r\n      const temp = mergeArray(arr, L1, R1, L2, R2);\r\n      let j = 0;\r\n      do {\r\n        arr[i + j] = temp[j];\r\n        globalSnapshot.push([...arr]);\r\n        j++;\r\n      } while (j <= R2 - L1 + 1);\r\n      i = i + 2 * size;\r\n    } while (i < len);\r\n    size = 2 * size;\r\n  } while (size < len);\r\n  globalSnapshot = [[arr]];\r\n  return globalSnapshot;\r\n};\r\n\r\nconst mergeArray = (arr, L1, R1, L2, R2) => {\r\n  let temp = [];\r\n  let i = 0;\r\n  // While Both Sub-Arrays Can Be Spliced\r\n  do {\r\n    if (arr[L1] <= arr[L2]) {\r\n      temp[i] = arr[L1];\r\n      i++;\r\n      L1++;\r\n    } else {\r\n      temp[i] = arr[L2];\r\n      i++;\r\n      L2++;\r\n    }\r\n  } while (L1 <= R1 && L2 <= R2);\r\n\r\n  // While Left Sub-Arrays Can Be Spliced\r\n  do {\r\n    temp[i] = arr[L1];\r\n    i++;\r\n    L1++;\r\n  } while (L1 <= R1);\r\n\r\n  // While Right Sub-Arrays Can Be Spliced\r\n  do {\r\n    temp[i] = arr[L2];\r\n    i++;\r\n    L2++;\r\n  } while (L2 <= R2);\r\n\r\n  return temp;\r\n};\r\n\r\nexport default mergeSort;\r\n"]},"metadata":{},"sourceType":"module"}