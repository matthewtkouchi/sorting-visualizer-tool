{"ast":null,"code":"const mergeSort = arr => {\n  const midpoint = arr.length / 2;\n  const arrSnapshot = [[...arr]]; // Base case\n\n  if (arr.length < 2) {\n    return arr;\n  }\n\n  const splitArr = arr.splice(0, midpoint);\n  merge(mergeSort(splitArr), mergeSort(arr));\n  return arrSnapshot;\n};\n\nconst merge = (left, right) => {\n  let arr = []; // Break out of loop if any one of the array gets empty\n\n  while (left.length && right.length) {\n    // Pick the smaller among the smallest element of left and right sub arrays\n    if (left[0] < right[0]) {\n      arr.push(left.shift());\n    } else {\n      arr.push(right.shift());\n    }\n  } // Concatenating the leftover elements\n  // (in case we didn't go through the entire left or right array)\n\n\n  return [...arr, ...left, ...right];\n};\n\nexport default mergeSort;","map":{"version":3,"sources":["C:/Users/mkouc/OneDrive/Desktop/sorting_visualizer/src/scripts/algorithms/mergeSort.js"],"names":["mergeSort","arr","midpoint","length","arrSnapshot","splitArr","splice","merge","left","right","push","shift"],"mappings":"AAAA,MAAMA,SAAS,GAAIC,GAAD,IAAS;AACzB,QAAMC,QAAQ,GAAGD,GAAG,CAACE,MAAJ,GAAa,CAA9B;AACA,QAAMC,WAAW,GAAG,CAAC,CAAC,GAAGH,GAAJ,CAAD,CAApB,CAFyB,CAIzB;;AACA,MAAIA,GAAG,CAACE,MAAJ,GAAa,CAAjB,EAAoB;AAClB,WAAOF,GAAP;AACD;;AAED,QAAMI,QAAQ,GAAGJ,GAAG,CAACK,MAAJ,CAAW,CAAX,EAAcJ,QAAd,CAAjB;AACAK,EAAAA,KAAK,CAACP,SAAS,CAACK,QAAD,CAAV,EAAsBL,SAAS,CAACC,GAAD,CAA/B,CAAL;AAEA,SAAOG,WAAP;AACD,CAbD;;AAeA,MAAMG,KAAK,GAAG,CAACC,IAAD,EAAOC,KAAP,KAAiB;AAC7B,MAAIR,GAAG,GAAG,EAAV,CAD6B,CAE7B;;AACA,SAAOO,IAAI,CAACL,MAAL,IAAeM,KAAK,CAACN,MAA5B,EAAoC;AAClC;AACA,QAAIK,IAAI,CAAC,CAAD,CAAJ,GAAUC,KAAK,CAAC,CAAD,CAAnB,EAAwB;AACtBR,MAAAA,GAAG,CAACS,IAAJ,CAASF,IAAI,CAACG,KAAL,EAAT;AACD,KAFD,MAEO;AACLV,MAAAA,GAAG,CAACS,IAAJ,CAASD,KAAK,CAACE,KAAN,EAAT;AACD;AACF,GAV4B,CAY7B;AACA;;;AACA,SAAO,CAAC,GAAGV,GAAJ,EAAS,GAAGO,IAAZ,EAAkB,GAAGC,KAArB,CAAP;AACD,CAfD;;AAiBA,eAAeT,SAAf","sourcesContent":["const mergeSort = (arr) => {\r\n  const midpoint = arr.length / 2;\r\n  const arrSnapshot = [[...arr]];\r\n\r\n  // Base case\r\n  if (arr.length < 2) {\r\n    return arr;\r\n  }\r\n\r\n  const splitArr = arr.splice(0, midpoint);\r\n  merge(mergeSort(splitArr), mergeSort(arr));\r\n\r\n  return arrSnapshot;\r\n};\r\n\r\nconst merge = (left, right) => {\r\n  let arr = [];\r\n  // Break out of loop if any one of the array gets empty\r\n  while (left.length && right.length) {\r\n    // Pick the smaller among the smallest element of left and right sub arrays\r\n    if (left[0] < right[0]) {\r\n      arr.push(left.shift());\r\n    } else {\r\n      arr.push(right.shift());\r\n    }\r\n  }\r\n\r\n  // Concatenating the leftover elements\r\n  // (in case we didn't go through the entire left or right array)\r\n  return [...arr, ...left, ...right];\r\n};\r\n\r\nexport default mergeSort;\r\n"]},"metadata":{},"sourceType":"module"}