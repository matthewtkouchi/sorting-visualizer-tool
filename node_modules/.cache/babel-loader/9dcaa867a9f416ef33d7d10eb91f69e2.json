{"ast":null,"code":"const mergeSort = arr => {\n  const half = arr.length / 2; // Base case or terminating case\n\n  if (arr.length < 2) {\n    return arr;\n  }\n\n  const left = arr.splice(0, half);\n  return merge(mergeSort(left), mergeSort(arr));\n};\n\nconst merge = (left, right) => {\n  let arr = []; // Break out of loop if any one of the array gets empty\n\n  while (left.length && right.length) {\n    // Pick the smaller among the smallest element of left and right sub arrays\n    if (left[0] < right[0]) {\n      arr.push(left.shift());\n    } else {\n      arr.push(right.shift());\n    }\n  } // Concatenating the leftover elements\n  // (in case we didn't go through the entire left or right array)\n\n\n  return [...arr, ...left, ...right];\n};","map":{"version":3,"sources":["C:/Users/mkouc/OneDrive/Desktop/sorting_visualizer/src/scripts/algorithms/mergeSort.js"],"names":["mergeSort","arr","half","length","left","splice","merge","right","push","shift"],"mappings":"AAAA,MAAMA,SAAS,GAAIC,GAAD,IAAS;AACzB,QAAMC,IAAI,GAAGD,GAAG,CAACE,MAAJ,GAAa,CAA1B,CADyB,CAGzB;;AACA,MAAIF,GAAG,CAACE,MAAJ,GAAa,CAAjB,EAAoB;AAClB,WAAOF,GAAP;AACD;;AAED,QAAMG,IAAI,GAAGH,GAAG,CAACI,MAAJ,CAAW,CAAX,EAAcH,IAAd,CAAb;AACA,SAAOI,KAAK,CAACN,SAAS,CAACI,IAAD,CAAV,EAAkBJ,SAAS,CAACC,GAAD,CAA3B,CAAZ;AACD,CAVD;;AAYA,MAAMK,KAAK,GAAG,CAACF,IAAD,EAAOG,KAAP,KAAiB;AAC7B,MAAIN,GAAG,GAAG,EAAV,CAD6B,CAE7B;;AACA,SAAOG,IAAI,CAACD,MAAL,IAAeI,KAAK,CAACJ,MAA5B,EAAoC;AAClC;AACA,QAAIC,IAAI,CAAC,CAAD,CAAJ,GAAUG,KAAK,CAAC,CAAD,CAAnB,EAAwB;AACtBN,MAAAA,GAAG,CAACO,IAAJ,CAASJ,IAAI,CAACK,KAAL,EAAT;AACD,KAFD,MAEO;AACLR,MAAAA,GAAG,CAACO,IAAJ,CAASD,KAAK,CAACE,KAAN,EAAT;AACD;AACF,GAV4B,CAY7B;AACA;;;AACA,SAAO,CAAC,GAAGR,GAAJ,EAAS,GAAGG,IAAZ,EAAkB,GAAGG,KAArB,CAAP;AACD,CAfD","sourcesContent":["const mergeSort = (arr) => {\r\n  const half = arr.length / 2;\r\n\r\n  // Base case or terminating case\r\n  if (arr.length < 2) {\r\n    return arr;\r\n  }\r\n\r\n  const left = arr.splice(0, half);\r\n  return merge(mergeSort(left), mergeSort(arr));\r\n};\r\n\r\nconst merge = (left, right) => {\r\n  let arr = [];\r\n  // Break out of loop if any one of the array gets empty\r\n  while (left.length && right.length) {\r\n    // Pick the smaller among the smallest element of left and right sub arrays\r\n    if (left[0] < right[0]) {\r\n      arr.push(left.shift());\r\n    } else {\r\n      arr.push(right.shift());\r\n    }\r\n  }\r\n\r\n  // Concatenating the leftover elements\r\n  // (in case we didn't go through the entire left or right array)\r\n  return [...arr, ...left, ...right];\r\n};\r\n"]},"metadata":{},"sourceType":"module"}