{"ast":null,"code":"// const globalSnapshot = [];\n// const mergeSort = (arr) => {\n//   mergeSortHelper(arr);\n//   return globalSnapshot;\n// };\n// const mergeSortHelper = (a) => {\n//   if (a.length < 2) return a;\n//   const middle = Math.floor(a.length / 2);\n//   const a_l = a.slice(0, middle);\n//   const a_r = a.slice(middle, a.length);\n//   const sorted_l = mergeSortHelper(a_l);\n//   const sorted_r = mergeSortHelper(a_r);\n//   return mergeArrays(sorted_l, sorted_r);\n// };\n// const mergeArrays = (a, b) => {\n//   const c = [];\n//   while (a.length && b.length) {\n//     c.push(a[0] > b[0] ? b.shift() : a.shift());\n//   }\n//   //if we still have values, let's add them at the end of `c`\n//   while (a.length) {\n//     c.push(a.shift());\n//   }\n//   while (b.length) {\n//     c.push(b.shift());\n//   }\n//   return c;\n// };\nimport { generateRandomArr } from \"../algorithms/util\";\nexport const printArr = () => {\n  const unsortedArr = generateRandomArr();\n  console.log(unsortedArr);\n  const arr = mergeSort(unsortedArr);\n  console.log(arr);\n};\n\nconst mergeSort = arr => {\n  let size = 1;\n  const len = arr.length;\n\n  do {\n    let i = 0;\n\n    do {\n      const L1 = i;\n      const R1 = i + size - 1;\n      const L2 = i + size;\n      let R2 = i + 2 * size - 1;\n      if (L2 >= len) break;\n      if (R2 >= len) R2 = len - 1;\n      const temp = mergeArray(arr, L1, R1, L2, R2);\n      let j = 0;\n\n      do {\n        arr[i + j] = temp[j];\n        j++;\n      } while (j != R2 - L1 + 1);\n\n      i = i + 2 * size;\n    } while (i < len);\n\n    size = 2 * size;\n  } while (size < len);\n\n  return arr;\n};\n\nconst mergeArray = (arr, L1, R1, L2, R2) => {\n  let temp = [];\n  let i = 0; // While Both Sub-Arrays Can Be Spliced\n\n  do {\n    if (arr[L1] <= arr[L2]) {\n      temp[i] = arr[L1];\n      i++;\n      L1++;\n    } else {\n      temp[i] = arr[L2];\n      i++;\n      L2++;\n    }\n  } while (L1 <= R1 && L2 <= R2); // While Left Sub-Arrays Can Be Spliced\n\n\n  do {\n    temp[i] = arr[L1];\n    i++;\n    L1++;\n  } while (L1 <= R1); // While Right Sub-Arrays Can Be Spliced\n\n\n  do {\n    temp[i] = arr[L2];\n    i++;\n    L2++;\n  } while (L2 <= R2);\n\n  return temp;\n};\n\nexport default mergeSort;","map":{"version":3,"sources":["C:/Users/mkouc/OneDrive/Desktop/sorting_visualizer/src/scripts/algorithms/mergeSort.js"],"names":["generateRandomArr","printArr","unsortedArr","console","log","arr","mergeSort","size","len","length","i","L1","R1","L2","R2","temp","mergeArray","j"],"mappings":"AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA,SAASA,iBAAT,QAAkC,oBAAlC;AAEA,OAAO,MAAMC,QAAQ,GAAG,MAAM;AAC5B,QAAMC,WAAW,GAAGF,iBAAiB,EAArC;AACAG,EAAAA,OAAO,CAACC,GAAR,CAAYF,WAAZ;AACA,QAAMG,GAAG,GAAGC,SAAS,CAACJ,WAAD,CAArB;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAYC,GAAZ;AACD,CALM;;AAOP,MAAMC,SAAS,GAAID,GAAD,IAAS;AACzB,MAAIE,IAAI,GAAG,CAAX;AACA,QAAMC,GAAG,GAAGH,GAAG,CAACI,MAAhB;;AACA,KAAG;AACD,QAAIC,CAAC,GAAG,CAAR;;AACA,OAAG;AACD,YAAMC,EAAE,GAAGD,CAAX;AACA,YAAME,EAAE,GAAGF,CAAC,GAAGH,IAAJ,GAAW,CAAtB;AACA,YAAMM,EAAE,GAAGH,CAAC,GAAGH,IAAf;AACA,UAAIO,EAAE,GAAGJ,CAAC,GAAG,IAAIH,IAAR,GAAe,CAAxB;AACA,UAAIM,EAAE,IAAIL,GAAV,EAAe;AACf,UAAIM,EAAE,IAAIN,GAAV,EAAeM,EAAE,GAAGN,GAAG,GAAG,CAAX;AACf,YAAMO,IAAI,GAAGC,UAAU,CAACX,GAAD,EAAMM,EAAN,EAAUC,EAAV,EAAcC,EAAd,EAAkBC,EAAlB,CAAvB;AACA,UAAIG,CAAC,GAAG,CAAR;;AACA,SAAG;AACDZ,QAAAA,GAAG,CAACK,CAAC,GAAGO,CAAL,CAAH,GAAaF,IAAI,CAACE,CAAD,CAAjB;AACAA,QAAAA,CAAC;AACF,OAHD,QAGSA,CAAC,IAAIH,EAAE,GAAGH,EAAL,GAAU,CAHxB;;AAIAD,MAAAA,CAAC,GAAGA,CAAC,GAAG,IAAIH,IAAZ;AACD,KAdD,QAcSG,CAAC,GAAGF,GAdb;;AAeAD,IAAAA,IAAI,GAAG,IAAIA,IAAX;AACD,GAlBD,QAkBSA,IAAI,GAAGC,GAlBhB;;AAmBA,SAAOH,GAAP;AACD,CAvBD;;AAyBA,MAAMW,UAAU,GAAG,CAACX,GAAD,EAAMM,EAAN,EAAUC,EAAV,EAAcC,EAAd,EAAkBC,EAAlB,KAAyB;AAC1C,MAAIC,IAAI,GAAG,EAAX;AACA,MAAIL,CAAC,GAAG,CAAR,CAF0C,CAG1C;;AACA,KAAG;AACD,QAAIL,GAAG,CAACM,EAAD,CAAH,IAAWN,GAAG,CAACQ,EAAD,CAAlB,EAAwB;AACtBE,MAAAA,IAAI,CAACL,CAAD,CAAJ,GAAUL,GAAG,CAACM,EAAD,CAAb;AACAD,MAAAA,CAAC;AACDC,MAAAA,EAAE;AACH,KAJD,MAIO;AACLI,MAAAA,IAAI,CAACL,CAAD,CAAJ,GAAUL,GAAG,CAACQ,EAAD,CAAb;AACAH,MAAAA,CAAC;AACDG,MAAAA,EAAE;AACH;AACF,GAVD,QAUSF,EAAE,IAAIC,EAAN,IAAYC,EAAE,IAAIC,EAV3B,EAJ0C,CAgB1C;;;AACA,KAAG;AACDC,IAAAA,IAAI,CAACL,CAAD,CAAJ,GAAUL,GAAG,CAACM,EAAD,CAAb;AACAD,IAAAA,CAAC;AACDC,IAAAA,EAAE;AACH,GAJD,QAISA,EAAE,IAAIC,EAJf,EAjB0C,CAuB1C;;;AACA,KAAG;AACDG,IAAAA,IAAI,CAACL,CAAD,CAAJ,GAAUL,GAAG,CAACQ,EAAD,CAAb;AACAH,IAAAA,CAAC;AACDG,IAAAA,EAAE;AACH,GAJD,QAISA,EAAE,IAAIC,EAJf;;AAMA,SAAOC,IAAP;AACD,CA/BD;;AAiCA,eAAeT,SAAf","sourcesContent":["// const globalSnapshot = [];\r\n\r\n// const mergeSort = (arr) => {\r\n//   mergeSortHelper(arr);\r\n\r\n//   return globalSnapshot;\r\n// };\r\n\r\n// const mergeSortHelper = (a) => {\r\n//   if (a.length < 2) return a;\r\n//   const middle = Math.floor(a.length / 2);\r\n//   const a_l = a.slice(0, middle);\r\n//   const a_r = a.slice(middle, a.length);\r\n//   const sorted_l = mergeSortHelper(a_l);\r\n//   const sorted_r = mergeSortHelper(a_r);\r\n//   return mergeArrays(sorted_l, sorted_r);\r\n// };\r\n\r\n// const mergeArrays = (a, b) => {\r\n//   const c = [];\r\n\r\n//   while (a.length && b.length) {\r\n//     c.push(a[0] > b[0] ? b.shift() : a.shift());\r\n\r\n//   }\r\n\r\n//   //if we still have values, let's add them at the end of `c`\r\n//   while (a.length) {\r\n//     c.push(a.shift());\r\n//   }\r\n//   while (b.length) {\r\n//     c.push(b.shift());\r\n//   }\r\n\r\n//   return c;\r\n// };\r\n\r\nimport { generateRandomArr } from \"../algorithms/util\";\r\n\r\nexport const printArr = () => {\r\n  const unsortedArr = generateRandomArr();\r\n  console.log(unsortedArr);\r\n  const arr = mergeSort(unsortedArr);\r\n  console.log(arr);\r\n};\r\n\r\nconst mergeSort = (arr) => {\r\n  let size = 1;\r\n  const len = arr.length;\r\n  do {\r\n    let i = 0;\r\n    do {\r\n      const L1 = i;\r\n      const R1 = i + size - 1;\r\n      const L2 = i + size;\r\n      let R2 = i + 2 * size - 1;\r\n      if (L2 >= len) break;\r\n      if (R2 >= len) R2 = len - 1;\r\n      const temp = mergeArray(arr, L1, R1, L2, R2);\r\n      let j = 0;\r\n      do {\r\n        arr[i + j] = temp[j];\r\n        j++;\r\n      } while (j != R2 - L1 + 1);\r\n      i = i + 2 * size;\r\n    } while (i < len);\r\n    size = 2 * size;\r\n  } while (size < len);\r\n  return arr;\r\n};\r\n\r\nconst mergeArray = (arr, L1, R1, L2, R2) => {\r\n  let temp = [];\r\n  let i = 0;\r\n  // While Both Sub-Arrays Can Be Spliced\r\n  do {\r\n    if (arr[L1] <= arr[L2]) {\r\n      temp[i] = arr[L1];\r\n      i++;\r\n      L1++;\r\n    } else {\r\n      temp[i] = arr[L2];\r\n      i++;\r\n      L2++;\r\n    }\r\n  } while (L1 <= R1 && L2 <= R2);\r\n\r\n  // While Left Sub-Arrays Can Be Spliced\r\n  do {\r\n    temp[i] = arr[L1];\r\n    i++;\r\n    L1++;\r\n  } while (L1 <= R1);\r\n\r\n  // While Right Sub-Arrays Can Be Spliced\r\n  do {\r\n    temp[i] = arr[L2];\r\n    i++;\r\n    L2++;\r\n  } while (L2 <= R2);\r\n\r\n  return temp;\r\n};\r\n\r\nexport default mergeSort;\r\n"]},"metadata":{},"sourceType":"module"}