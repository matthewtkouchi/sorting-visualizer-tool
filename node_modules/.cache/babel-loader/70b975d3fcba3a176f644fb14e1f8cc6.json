{"ast":null,"code":"/***************************************************************************************************************************************\r\n Name: Matthew Kouchi\r\n File: quickSort.js\r\n Date: JUN_6_2021\r\n \r\n Abstract: Quick sort uses a pivot and partitions the array to have indexes with lesser values on one side and with greater values on\r\n the opposite side. Then afer setting a new pivot by ... , the array is partitioned again. This is done by recursivley calling \r\n quick sort on both sides of the pivot (both sides essentially act as individual arrays) This goes on until the starting idx is equal to \r\n or greater than the end idx, meaning each partition is just a single element.  \r\n***************************************************************************************************************************************/\nimport { swap } from \"./util\";\n\nconst quickSort = unsortedArray => {\n  //Takes in unsorted Array\n  // Declarations\n  let arr = [...unsortedArray]; //Initialize arr to the unsorted arr and store the arr in a snapshot container\n\n  let arrSnapshot = [[...arr]];\n  const startIdx = 0;\n  const endIdx = arr.length - 1; // Call Sorting Algorithm with Initial Conditions\n\n  arrSnapshot = doQuick(arr, startIdx, endIdx, arrSnapshot);\n  return arrSnapshot;\n};\n\nconst doQuick = (arr, start, end, arrSnapshot) => {\n  // Check if array is fully partitioned\n  if (start >= end) {\n    return arrSnapshot;\n  } // Declare a pivot idx\n\n\n  let container = partition(arr, start, end, arrSnapshot);\n  let index = container[container.length - 1];\n  container.pop();\n  arrSnapshot = arrSnapshot.concat(container); // Recursivley quick sort either side of the pivot idx\n\n  doQuick(arr, start, index - 1, arrSnapshot);\n  doQuick(arr, index + 1, end, arrSnapshot);\n  return arrSnapshot;\n};\n\nconst partition = (arr, start, end, initArr) => {\n  let pivotValue = arr[end];\n  let pivotIdx = start;\n  let snap = [[...initArr]];\n\n  for (let i = start; i < end; i++) {\n    if (arr[i] < pivotValue) {\n      swap(arr, i, pivotIdx);\n      snap.push([...arr]);\n      pivotIdx++;\n    }\n  }\n\n  swap(arr, pivotIdx, end);\n  snap.push([...arr]); // Reset Props to Initials\n\n  snap[snap.length - 1].forEach(idx => {\n    idx.highlighted = false;\n  });\n  const arrSnapshot = snap.concat(pivotIdx);\n  return arrSnapshot;\n};\n\nexport default quickSort;","map":{"version":3,"sources":["C:/Users/mkouc/sorting_visualizer/src/scripts/algorithms/quickSort.js"],"names":["swap","quickSort","unsortedArray","arr","arrSnapshot","startIdx","endIdx","length","doQuick","start","end","container","partition","index","pop","concat","initArr","pivotValue","pivotIdx","snap","i","push","forEach","idx","highlighted"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,IAAT,QAAqB,QAArB;;AAEA,MAAMC,SAAS,GAAIC,aAAD,IAAmB;AACnC;AACA;AACA,MAAIC,GAAG,GAAG,CAAC,GAAGD,aAAJ,CAAV,CAHmC,CAGL;;AAC9B,MAAIE,WAAW,GAAG,CAAC,CAAC,GAAGD,GAAJ,CAAD,CAAlB;AACA,QAAME,QAAQ,GAAG,CAAjB;AACA,QAAMC,MAAM,GAAGH,GAAG,CAACI,MAAJ,GAAa,CAA5B,CANmC,CAQnC;;AACAH,EAAAA,WAAW,GAAGI,OAAO,CAACL,GAAD,EAAME,QAAN,EAAgBC,MAAhB,EAAwBF,WAAxB,CAArB;AAEA,SAAOA,WAAP;AACD,CAZD;;AAcA,MAAMI,OAAO,GAAG,CAACL,GAAD,EAAMM,KAAN,EAAaC,GAAb,EAAkBN,WAAlB,KAAkC;AAChD;AACA,MAAIK,KAAK,IAAIC,GAAb,EAAkB;AAChB,WAAON,WAAP;AACD,GAJ+C,CAMhD;;;AACA,MAAIO,SAAS,GAAGC,SAAS,CAACT,GAAD,EAAMM,KAAN,EAAaC,GAAb,EAAkBN,WAAlB,CAAzB;AACA,MAAIS,KAAK,GAAGF,SAAS,CAACA,SAAS,CAACJ,MAAV,GAAmB,CAApB,CAArB;AAEAI,EAAAA,SAAS,CAACG,GAAV;AACAV,EAAAA,WAAW,GAAGA,WAAW,CAACW,MAAZ,CAAmBJ,SAAnB,CAAd,CAXgD,CAYhD;;AACAH,EAAAA,OAAO,CAACL,GAAD,EAAMM,KAAN,EAAaI,KAAK,GAAG,CAArB,EAAwBT,WAAxB,CAAP;AACAI,EAAAA,OAAO,CAACL,GAAD,EAAMU,KAAK,GAAG,CAAd,EAAiBH,GAAjB,EAAsBN,WAAtB,CAAP;AAEA,SAAOA,WAAP;AACD,CAjBD;;AAmBA,MAAMQ,SAAS,GAAG,CAACT,GAAD,EAAMM,KAAN,EAAaC,GAAb,EAAkBM,OAAlB,KAA8B;AAC9C,MAAIC,UAAU,GAAGd,GAAG,CAACO,GAAD,CAApB;AACA,MAAIQ,QAAQ,GAAGT,KAAf;AACA,MAAIU,IAAI,GAAG,CAAC,CAAC,GAAGH,OAAJ,CAAD,CAAX;;AACA,OAAK,IAAII,CAAC,GAAGX,KAAb,EAAoBW,CAAC,GAAGV,GAAxB,EAA6BU,CAAC,EAA9B,EAAkC;AAChC,QAAIjB,GAAG,CAACiB,CAAD,CAAH,GAASH,UAAb,EAAyB;AACvBjB,MAAAA,IAAI,CAACG,GAAD,EAAMiB,CAAN,EAASF,QAAT,CAAJ;AACAC,MAAAA,IAAI,CAACE,IAAL,CAAU,CAAC,GAAGlB,GAAJ,CAAV;AACAe,MAAAA,QAAQ;AACT;AACF;;AACDlB,EAAAA,IAAI,CAACG,GAAD,EAAMe,QAAN,EAAgBR,GAAhB,CAAJ;AACAS,EAAAA,IAAI,CAACE,IAAL,CAAU,CAAC,GAAGlB,GAAJ,CAAV,EAZ8C,CAc9C;;AACAgB,EAAAA,IAAI,CAACA,IAAI,CAACZ,MAAL,GAAc,CAAf,CAAJ,CAAsBe,OAAtB,CAA+BC,GAAD,IAAS;AACrCA,IAAAA,GAAG,CAACC,WAAJ,GAAkB,KAAlB;AACD,GAFD;AAIA,QAAMpB,WAAW,GAAGe,IAAI,CAACJ,MAAL,CAAYG,QAAZ,CAApB;AAEA,SAAOd,WAAP;AACD,CAtBD;;AAwBA,eAAeH,SAAf","sourcesContent":["/***************************************************************************************************************************************\r\n Name: Matthew Kouchi\r\n File: quickSort.js\r\n Date: JUN_6_2021\r\n \r\n Abstract: Quick sort uses a pivot and partitions the array to have indexes with lesser values on one side and with greater values on\r\n the opposite side. Then afer setting a new pivot by ... , the array is partitioned again. This is done by recursivley calling \r\n quick sort on both sides of the pivot (both sides essentially act as individual arrays) This goes on until the starting idx is equal to \r\n or greater than the end idx, meaning each partition is just a single element.  \r\n***************************************************************************************************************************************/\r\n\r\nimport { swap } from \"./util\";\r\n\r\nconst quickSort = (unsortedArray) => {\r\n  //Takes in unsorted Array\r\n  // Declarations\r\n  let arr = [...unsortedArray]; //Initialize arr to the unsorted arr and store the arr in a snapshot container\r\n  let arrSnapshot = [[...arr]];\r\n  const startIdx = 0;\r\n  const endIdx = arr.length - 1;\r\n\r\n  // Call Sorting Algorithm with Initial Conditions\r\n  arrSnapshot = doQuick(arr, startIdx, endIdx, arrSnapshot);\r\n\r\n  return arrSnapshot;\r\n};\r\n\r\nconst doQuick = (arr, start, end, arrSnapshot) => {\r\n  // Check if array is fully partitioned\r\n  if (start >= end) {\r\n    return arrSnapshot;\r\n  }\r\n\r\n  // Declare a pivot idx\r\n  let container = partition(arr, start, end, arrSnapshot);\r\n  let index = container[container.length - 1];\r\n\r\n  container.pop();\r\n  arrSnapshot = arrSnapshot.concat(container);\r\n  // Recursivley quick sort either side of the pivot idx\r\n  doQuick(arr, start, index - 1, arrSnapshot);\r\n  doQuick(arr, index + 1, end, arrSnapshot);\r\n\r\n  return arrSnapshot;\r\n};\r\n\r\nconst partition = (arr, start, end, initArr) => {\r\n  let pivotValue = arr[end];\r\n  let pivotIdx = start;\r\n  let snap = [[...initArr]];\r\n  for (let i = start; i < end; i++) {\r\n    if (arr[i] < pivotValue) {\r\n      swap(arr, i, pivotIdx);\r\n      snap.push([...arr]);\r\n      pivotIdx++;\r\n    }\r\n  }\r\n  swap(arr, pivotIdx, end);\r\n  snap.push([...arr]);\r\n\r\n  // Reset Props to Initials\r\n  snap[snap.length - 1].forEach((idx) => {\r\n    idx.highlighted = false;\r\n  });\r\n\r\n  const arrSnapshot = snap.concat(pivotIdx);\r\n\r\n  return arrSnapshot;\r\n};\r\n\r\nexport default quickSort;\r\n"]},"metadata":{},"sourceType":"module"}