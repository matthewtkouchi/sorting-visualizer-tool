{"ast":null,"code":"/***************************************************************************************************************************************\r\n Name: Matthew Kouchi\r\n File: heapSort.js\r\n Date: JUN_16_2021\r\n \r\n Abstract: Heap sort creates Max Heaps out of the unsorted array. Max heaps are binary trees in which the parent node's value is always\r\n greater than the children. For every i index is used to describe each array elements position in the heap. Then the highest node \r\n (the greatest value) is sorted into the highest index of your sorted array, and a method used heapify is called to maintain the max\r\n heap. Heapify finds the max value index and swaps it with the highest parent node. \r\n***************************************************************************************************************************************/\nimport { swap, highlightIdx, clearIdx } from \"./util\";\nlet globalSnapshot = [];\nlet globalArr = [];\n\nconst heapSort = arr => {\n  globalArr = [...arr];\n  globalSnapshot = [[...arr]];\n  let len = arr.length;\n  let i = 0; // Build Max Heap\n\n  for (i = Math.floor(len / 2 - 1); i >= 0; i--) heapify(globalArr, len, i); // Extract elements from the heap and move to sorted container\n\n\n  for (i = arr.length - 1; i >= 0; i--) {\n    // Move root to the end\n    highlightIdx(globalArr, i);\n    highlightIdx(globalArr, 0);\n    swap(globalArr, 0, i);\n    globalSnapshot.push([...globalArr]);\n    len--; // Creating new max heap after removing max element\n\n    heapify(globalArr, len, 0);\n  }\n\n  return globalSnapshot;\n};\n\nconst heapify = (arr, length, i) => {\n  // Define binary tree idx's\n  let max = i;\n  const left = 2 * i + 1;\n  const right = 2 * i + 2;\n  const len = length; // If left child > root\n\n  if (left < len && arr[left].value > arr[max].value) max = left; // If right child > root\n\n  if (right < len && arr[right].value > arr[max].value) max = right; //If max != root, set new max\n\n  if (max !== i) {\n    swap(globalArr, i, max);\n    globalSnapshot.push([...globalArr]);\n    heapify(globalArr, len, max);\n  }\n};\n\nexport default heapSort;","map":{"version":3,"sources":["C:/Users/mkouc/OneDrive/Desktop/sorting_visualizer/src/scripts/algorithms/heapSort.js"],"names":["swap","highlightIdx","clearIdx","globalSnapshot","globalArr","heapSort","arr","len","length","i","Math","floor","heapify","push","max","left","right","value"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,IAAT,EAAeC,YAAf,EAA6BC,QAA7B,QAA6C,QAA7C;AAEA,IAAIC,cAAc,GAAG,EAArB;AACA,IAAIC,SAAS,GAAG,EAAhB;;AAEA,MAAMC,QAAQ,GAAIC,GAAD,IAAS;AACxBF,EAAAA,SAAS,GAAG,CAAC,GAAGE,GAAJ,CAAZ;AACAH,EAAAA,cAAc,GAAG,CAAC,CAAC,GAAGG,GAAJ,CAAD,CAAjB;AACA,MAAIC,GAAG,GAAGD,GAAG,CAACE,MAAd;AACA,MAAIC,CAAC,GAAG,CAAR,CAJwB,CAMxB;;AACA,OAAKA,CAAC,GAAGC,IAAI,CAACC,KAAL,CAAWJ,GAAG,GAAG,CAAN,GAAU,CAArB,CAAT,EAAkCE,CAAC,IAAI,CAAvC,EAA0CA,CAAC,EAA3C,EAA+CG,OAAO,CAACR,SAAD,EAAYG,GAAZ,EAAiBE,CAAjB,CAAP,CAPvB,CASxB;;;AACA,OAAKA,CAAC,GAAGH,GAAG,CAACE,MAAJ,GAAa,CAAtB,EAAyBC,CAAC,IAAI,CAA9B,EAAiCA,CAAC,EAAlC,EAAsC;AACpC;AACAR,IAAAA,YAAY,CAACG,SAAD,EAAYK,CAAZ,CAAZ;AACAR,IAAAA,YAAY,CAACG,SAAD,EAAY,CAAZ,CAAZ;AACAJ,IAAAA,IAAI,CAACI,SAAD,EAAY,CAAZ,EAAeK,CAAf,CAAJ;AACAN,IAAAA,cAAc,CAACU,IAAf,CAAoB,CAAC,GAAGT,SAAJ,CAApB;AACAG,IAAAA,GAAG,GANiC,CAOpC;;AACAK,IAAAA,OAAO,CAACR,SAAD,EAAYG,GAAZ,EAAiB,CAAjB,CAAP;AACD;;AACD,SAAOJ,cAAP;AACD,CArBD;;AAuBA,MAAMS,OAAO,GAAG,CAACN,GAAD,EAAME,MAAN,EAAcC,CAAd,KAAoB;AAClC;AACA,MAAIK,GAAG,GAAGL,CAAV;AACA,QAAMM,IAAI,GAAG,IAAIN,CAAJ,GAAQ,CAArB;AACA,QAAMO,KAAK,GAAG,IAAIP,CAAJ,GAAQ,CAAtB;AACA,QAAMF,GAAG,GAAGC,MAAZ,CALkC,CAOlC;;AACA,MAAIO,IAAI,GAAGR,GAAP,IAAcD,GAAG,CAACS,IAAD,CAAH,CAAUE,KAAV,GAAkBX,GAAG,CAACQ,GAAD,CAAH,CAASG,KAA7C,EAAoDH,GAAG,GAAGC,IAAN,CARlB,CASlC;;AACA,MAAIC,KAAK,GAAGT,GAAR,IAAeD,GAAG,CAACU,KAAD,CAAH,CAAWC,KAAX,GAAmBX,GAAG,CAACQ,GAAD,CAAH,CAASG,KAA/C,EAAsDH,GAAG,GAAGE,KAAN,CAVpB,CAWlC;;AACA,MAAIF,GAAG,KAAKL,CAAZ,EAAe;AACbT,IAAAA,IAAI,CAACI,SAAD,EAAYK,CAAZ,EAAeK,GAAf,CAAJ;AACAX,IAAAA,cAAc,CAACU,IAAf,CAAoB,CAAC,GAAGT,SAAJ,CAApB;AACAQ,IAAAA,OAAO,CAACR,SAAD,EAAYG,GAAZ,EAAiBO,GAAjB,CAAP;AACD;AACF,CAjBD;;AAmBA,eAAeT,QAAf","sourcesContent":["/***************************************************************************************************************************************\r\n Name: Matthew Kouchi\r\n File: heapSort.js\r\n Date: JUN_16_2021\r\n \r\n Abstract: Heap sort creates Max Heaps out of the unsorted array. Max heaps are binary trees in which the parent node's value is always\r\n greater than the children. For every i index is used to describe each array elements position in the heap. Then the highest node \r\n (the greatest value) is sorted into the highest index of your sorted array, and a method used heapify is called to maintain the max\r\n heap. Heapify finds the max value index and swaps it with the highest parent node. \r\n***************************************************************************************************************************************/\r\nimport { swap, highlightIdx, clearIdx } from \"./util\";\r\n\r\nlet globalSnapshot = [];\r\nlet globalArr = [];\r\n\r\nconst heapSort = (arr) => {\r\n  globalArr = [...arr];\r\n  globalSnapshot = [[...arr]];\r\n  let len = arr.length;\r\n  let i = 0;\r\n\r\n  // Build Max Heap\r\n  for (i = Math.floor(len / 2 - 1); i >= 0; i--) heapify(globalArr, len, i);\r\n\r\n  // Extract elements from the heap and move to sorted container\r\n  for (i = arr.length - 1; i >= 0; i--) {\r\n    // Move root to the end\r\n    highlightIdx(globalArr, i);\r\n    highlightIdx(globalArr, 0);\r\n    swap(globalArr, 0, i);\r\n    globalSnapshot.push([...globalArr]);\r\n    len--;\r\n    // Creating new max heap after removing max element\r\n    heapify(globalArr, len, 0);\r\n  }\r\n  return globalSnapshot;\r\n};\r\n\r\nconst heapify = (arr, length, i) => {\r\n  // Define binary tree idx's\r\n  let max = i;\r\n  const left = 2 * i + 1;\r\n  const right = 2 * i + 2;\r\n  const len = length;\r\n\r\n  // If left child > root\r\n  if (left < len && arr[left].value > arr[max].value) max = left;\r\n  // If right child > root\r\n  if (right < len && arr[right].value > arr[max].value) max = right;\r\n  //If max != root, set new max\r\n  if (max !== i) {\r\n    swap(globalArr, i, max);\r\n    globalSnapshot.push([...globalArr]);\r\n    heapify(globalArr, len, max);\r\n  }\r\n};\r\n\r\nexport default heapSort;\r\n"]},"metadata":{},"sourceType":"module"}