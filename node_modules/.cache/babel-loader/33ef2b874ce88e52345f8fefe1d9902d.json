{"ast":null,"code":"/*let globalSnapshot = [];\r\nlet globalArr = [];\r\n\r\nconst mergeSort = (arr) => {\r\n  const midpoint = arr.length / 2;\r\n  globalSnapshot = [[...arr]];\r\n  globalArr = arr;\r\n\r\n  // Base case\r\n  if (globalArr.length < 2) {\r\n    return arr;\r\n  }\r\n\r\n  const splitArr = arr.splice(0, midpoint);\r\n  merge(mergeSort(splitArr), mergeSort(globalArr));\r\n\r\n  return globalSnapshot;\r\n};\r\n\r\nconst merge = (left, right) => {\r\n  let arr = [];\r\n  // Break out of loop if any one of the array gets empty\r\n  while (left.length && right.length) {\r\n    // Pick the smaller among the smallest element of left and right sub arrays\r\n    if (left[0] < right[0]) {\r\n      arr.push(left.shift());\r\n      globalSnapshot.push([...arr]);\r\n    } else {\r\n      arr.push(right.shift());\r\n      globalSnapshot.push([...arr]);\r\n    }\r\n  }\r\n\r\n  // Concatenating the leftover elements\r\n  // (in case we didn't go through the entire left or right array)\r\n  return [...arr, ...left, ...right];\r\n}; */\nconst mergeSort = a => {\n  console.log(a);\n  if (a.length < 2) return a;\n  const middle = Math.floor(a.length / 2);\n  const a_l = a.slice(0, middle);\n  const a_r = a.slice(middle, a.length);\n  const sorted_l = mergeSort(a_l);\n  const sorted_r = mergeSort(a_r);\n  console.log(a);\n  return mergeSortHelper(sorted_l, sorted_r);\n};\n\nconst mergeSortHelper = (a, b) => {\n  const c = [];\n\n  while (a.length && b.length) {\n    c.push(a[0] > b[0] ? b.shift() : a.shift());\n  } //if we still have values, let's add them at the end of `c`\n\n\n  while (a.length) {\n    c.push(a.shift());\n  }\n\n  while (b.length) {\n    c.push(b.shift());\n  }\n\n  return c;\n};\n\nexport default mergeSort;","map":{"version":3,"sources":["C:/Users/mkouc/OneDrive/Desktop/sorting_visualizer/src/scripts/algorithms/mergeSort.js"],"names":["mergeSort","a","console","log","length","middle","Math","floor","a_l","slice","a_r","sorted_l","sorted_r","mergeSortHelper","b","c","push","shift"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,SAAS,GAAIC,CAAD,IAAO;AACvBC,EAAAA,OAAO,CAACC,GAAR,CAAYF,CAAZ;AACA,MAAIA,CAAC,CAACG,MAAF,GAAW,CAAf,EAAkB,OAAOH,CAAP;AAClB,QAAMI,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWN,CAAC,CAACG,MAAF,GAAW,CAAtB,CAAf;AACA,QAAMI,GAAG,GAAGP,CAAC,CAACQ,KAAF,CAAQ,CAAR,EAAWJ,MAAX,CAAZ;AACA,QAAMK,GAAG,GAAGT,CAAC,CAACQ,KAAF,CAAQJ,MAAR,EAAgBJ,CAAC,CAACG,MAAlB,CAAZ;AACA,QAAMO,QAAQ,GAAGX,SAAS,CAACQ,GAAD,CAA1B;AACA,QAAMI,QAAQ,GAAGZ,SAAS,CAACU,GAAD,CAA1B;AACAR,EAAAA,OAAO,CAACC,GAAR,CAAYF,CAAZ;AACA,SAAOY,eAAe,CAACF,QAAD,EAAWC,QAAX,CAAtB;AACD,CAVD;;AAYA,MAAMC,eAAe,GAAG,CAACZ,CAAD,EAAIa,CAAJ,KAAU;AAChC,QAAMC,CAAC,GAAG,EAAV;;AAEA,SAAOd,CAAC,CAACG,MAAF,IAAYU,CAAC,CAACV,MAArB,EAA6B;AAC3BW,IAAAA,CAAC,CAACC,IAAF,CAAOf,CAAC,CAAC,CAAD,CAAD,GAAOa,CAAC,CAAC,CAAD,CAAR,GAAcA,CAAC,CAACG,KAAF,EAAd,GAA0BhB,CAAC,CAACgB,KAAF,EAAjC;AACD,GAL+B,CAOhC;;;AACA,SAAOhB,CAAC,CAACG,MAAT,EAAiB;AACfW,IAAAA,CAAC,CAACC,IAAF,CAAOf,CAAC,CAACgB,KAAF,EAAP;AACD;;AACD,SAAOH,CAAC,CAACV,MAAT,EAAiB;AACfW,IAAAA,CAAC,CAACC,IAAF,CAAOF,CAAC,CAACG,KAAF,EAAP;AACD;;AAED,SAAOF,CAAP;AACD,CAhBD;;AAkBA,eAAef,SAAf","sourcesContent":["/*let globalSnapshot = [];\r\nlet globalArr = [];\r\n\r\nconst mergeSort = (arr) => {\r\n  const midpoint = arr.length / 2;\r\n  globalSnapshot = [[...arr]];\r\n  globalArr = arr;\r\n\r\n  // Base case\r\n  if (globalArr.length < 2) {\r\n    return arr;\r\n  }\r\n\r\n  const splitArr = arr.splice(0, midpoint);\r\n  merge(mergeSort(splitArr), mergeSort(globalArr));\r\n\r\n  return globalSnapshot;\r\n};\r\n\r\nconst merge = (left, right) => {\r\n  let arr = [];\r\n  // Break out of loop if any one of the array gets empty\r\n  while (left.length && right.length) {\r\n    // Pick the smaller among the smallest element of left and right sub arrays\r\n    if (left[0] < right[0]) {\r\n      arr.push(left.shift());\r\n      globalSnapshot.push([...arr]);\r\n    } else {\r\n      arr.push(right.shift());\r\n      globalSnapshot.push([...arr]);\r\n    }\r\n  }\r\n\r\n  // Concatenating the leftover elements\r\n  // (in case we didn't go through the entire left or right array)\r\n  return [...arr, ...left, ...right];\r\n}; */\r\n\r\nconst mergeSort = (a) => {\r\n  console.log(a);\r\n  if (a.length < 2) return a;\r\n  const middle = Math.floor(a.length / 2);\r\n  const a_l = a.slice(0, middle);\r\n  const a_r = a.slice(middle, a.length);\r\n  const sorted_l = mergeSort(a_l);\r\n  const sorted_r = mergeSort(a_r);\r\n  console.log(a);\r\n  return mergeSortHelper(sorted_l, sorted_r);\r\n};\r\n\r\nconst mergeSortHelper = (a, b) => {\r\n  const c = [];\r\n\r\n  while (a.length && b.length) {\r\n    c.push(a[0] > b[0] ? b.shift() : a.shift());\r\n  }\r\n\r\n  //if we still have values, let's add them at the end of `c`\r\n  while (a.length) {\r\n    c.push(a.shift());\r\n  }\r\n  while (b.length) {\r\n    c.push(b.shift());\r\n  }\r\n\r\n  return c;\r\n};\r\n\r\nexport default mergeSort;\r\n"]},"metadata":{},"sourceType":"module"}