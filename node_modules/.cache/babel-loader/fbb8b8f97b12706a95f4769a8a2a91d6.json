{"ast":null,"code":"/***************************************************************************************************************************************\r\n Name: Matthew Kouchi\r\n File: quickSort.js\r\n Date: JUN_6_2021\r\n \r\n Abstract: Quick sort uses a pivot and partitions the array to have indexes with lesser values on one side and with greater values on\r\n the opposite side. Then afer setting a new pivot by ... , the array is partitioned again. This is done by recursivley calling \r\n quick sort on both sides of the pivot (both sides essentially act as individual arrays) This goes on until the starting idx is equal to \r\n or greater than the end idx, meaning each partition is just a single element.  \r\n***************************************************************************************************************************************/\nimport { swap, highlightIdx, clearIdx } from \"./util\";\nlet globalSnapshot = [];\nlet globalArr = [];\n\nconst quickSort = arr => {\n  const start = 0;\n  const end = arr.length - 1;\n  globalArr = arr;\n  globalSnapshot = [[...arr]];\n  quickSortHelper(globalArr, start, end); // Algorithm finished Sorting\n\n  globalSnapshot[globalSnapshot.length - 1].forEach(idx => {\n    idx.highlighted = false;\n    idx.sorted = true;\n  });\n  return globalSnapshot;\n};\n\nconst quickSortHelper = (arr, start, end) => {\n  if (start >= end) {\n    return;\n  } // Get pivot point\n\n\n  const index = partition(arr, start, end); // Recursivley call helper function on both sides of the pivot\n\n  quickSortHelper(globalArr, start, index - 1);\n  quickSortHelper(globalArr, index + 1, end);\n};\n\nconst partition = (arr, start, end) => {\n  let pivotValue = arr[end].value;\n  let pivotIndex = start; // Move values < pivot to left of pivot, and values > pivot to right of pivot\n\n  for (let i = start; i < end; i++) {\n    highlightIdx(arr, i);\n    highlightIdx(arr, pivotIndex);\n\n    if (arr[i].value < pivotValue) {\n      swap(arr, i, pivotIndex);\n      globalArr = arr;\n      globalSnapshot.push([...arr]);\n      clearIdx(arr, pivotIndex);\n      clearIdx(arr, i);\n      pivotIndex++;\n    }\n\n    globalSnapshot.push([...arr]);\n    clearIdx(arr, pivotIndex);\n    clearIdx(arr, i);\n  }\n\n  swap(arr, pivotIndex, end);\n  globalArr = arr;\n  globalSnapshot.push([...arr]);\n  return pivotIndex;\n};\n\nexport default quickSort;","map":{"version":3,"sources":["C:/Users/mkouc/OneDrive/Desktop/sorting_visualizer/src/scripts/algorithms/quickSort.js"],"names":["swap","highlightIdx","clearIdx","globalSnapshot","globalArr","quickSort","arr","start","end","length","quickSortHelper","forEach","idx","highlighted","sorted","index","partition","pivotValue","value","pivotIndex","i","push"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,IAAT,EAAeC,YAAf,EAA6BC,QAA7B,QAA6C,QAA7C;AAEA,IAAIC,cAAc,GAAG,EAArB;AACA,IAAIC,SAAS,GAAG,EAAhB;;AAEA,MAAMC,SAAS,GAAIC,GAAD,IAAS;AACzB,QAAMC,KAAK,GAAG,CAAd;AACA,QAAMC,GAAG,GAAGF,GAAG,CAACG,MAAJ,GAAa,CAAzB;AACAL,EAAAA,SAAS,GAAGE,GAAZ;AACAH,EAAAA,cAAc,GAAG,CAAC,CAAC,GAAGG,GAAJ,CAAD,CAAjB;AAEAI,EAAAA,eAAe,CAACN,SAAD,EAAYG,KAAZ,EAAmBC,GAAnB,CAAf,CANyB,CAQzB;;AACAL,EAAAA,cAAc,CAACA,cAAc,CAACM,MAAf,GAAwB,CAAzB,CAAd,CAA0CE,OAA1C,CAAmDC,GAAD,IAAS;AACzDA,IAAAA,GAAG,CAACC,WAAJ,GAAkB,KAAlB;AACAD,IAAAA,GAAG,CAACE,MAAJ,GAAa,IAAb;AACD,GAHD;AAKA,SAAOX,cAAP;AACD,CAfD;;AAiBA,MAAMO,eAAe,GAAG,CAACJ,GAAD,EAAMC,KAAN,EAAaC,GAAb,KAAqB;AAC3C,MAAID,KAAK,IAAIC,GAAb,EAAkB;AAChB;AACD,GAH0C,CAK3C;;;AACA,QAAMO,KAAK,GAAGC,SAAS,CAACV,GAAD,EAAMC,KAAN,EAAaC,GAAb,CAAvB,CAN2C,CAQ3C;;AACAE,EAAAA,eAAe,CAACN,SAAD,EAAYG,KAAZ,EAAmBQ,KAAK,GAAG,CAA3B,CAAf;AACAL,EAAAA,eAAe,CAACN,SAAD,EAAYW,KAAK,GAAG,CAApB,EAAuBP,GAAvB,CAAf;AACD,CAXD;;AAaA,MAAMQ,SAAS,GAAG,CAACV,GAAD,EAAMC,KAAN,EAAaC,GAAb,KAAqB;AACrC,MAAIS,UAAU,GAAGX,GAAG,CAACE,GAAD,CAAH,CAASU,KAA1B;AACA,MAAIC,UAAU,GAAGZ,KAAjB,CAFqC,CAIrC;;AACA,OAAK,IAAIa,CAAC,GAAGb,KAAb,EAAoBa,CAAC,GAAGZ,GAAxB,EAA6BY,CAAC,EAA9B,EAAkC;AAChCnB,IAAAA,YAAY,CAACK,GAAD,EAAMc,CAAN,CAAZ;AACAnB,IAAAA,YAAY,CAACK,GAAD,EAAMa,UAAN,CAAZ;;AACA,QAAIb,GAAG,CAACc,CAAD,CAAH,CAAOF,KAAP,GAAeD,UAAnB,EAA+B;AAC7BjB,MAAAA,IAAI,CAACM,GAAD,EAAMc,CAAN,EAASD,UAAT,CAAJ;AACAf,MAAAA,SAAS,GAAGE,GAAZ;AACAH,MAAAA,cAAc,CAACkB,IAAf,CAAoB,CAAC,GAAGf,GAAJ,CAApB;AACAJ,MAAAA,QAAQ,CAACI,GAAD,EAAMa,UAAN,CAAR;AACAjB,MAAAA,QAAQ,CAACI,GAAD,EAAMc,CAAN,CAAR;AACAD,MAAAA,UAAU;AACX;;AACDhB,IAAAA,cAAc,CAACkB,IAAf,CAAoB,CAAC,GAAGf,GAAJ,CAApB;AACAJ,IAAAA,QAAQ,CAACI,GAAD,EAAMa,UAAN,CAAR;AACAjB,IAAAA,QAAQ,CAACI,GAAD,EAAMc,CAAN,CAAR;AACD;;AAEDpB,EAAAA,IAAI,CAACM,GAAD,EAAMa,UAAN,EAAkBX,GAAlB,CAAJ;AACAJ,EAAAA,SAAS,GAAGE,GAAZ;AACAH,EAAAA,cAAc,CAACkB,IAAf,CAAoB,CAAC,GAAGf,GAAJ,CAApB;AAEA,SAAOa,UAAP;AACD,CA1BD;;AA4BA,eAAed,SAAf","sourcesContent":["/***************************************************************************************************************************************\r\n Name: Matthew Kouchi\r\n File: quickSort.js\r\n Date: JUN_6_2021\r\n \r\n Abstract: Quick sort uses a pivot and partitions the array to have indexes with lesser values on one side and with greater values on\r\n the opposite side. Then afer setting a new pivot by ... , the array is partitioned again. This is done by recursivley calling \r\n quick sort on both sides of the pivot (both sides essentially act as individual arrays) This goes on until the starting idx is equal to \r\n or greater than the end idx, meaning each partition is just a single element.  \r\n***************************************************************************************************************************************/\r\n\r\nimport { swap, highlightIdx, clearIdx } from \"./util\";\r\n\r\nlet globalSnapshot = [];\r\nlet globalArr = [];\r\n\r\nconst quickSort = (arr) => {\r\n  const start = 0;\r\n  const end = arr.length - 1;\r\n  globalArr = arr;\r\n  globalSnapshot = [[...arr]];\r\n\r\n  quickSortHelper(globalArr, start, end);\r\n\r\n  // Algorithm finished Sorting\r\n  globalSnapshot[globalSnapshot.length - 1].forEach((idx) => {\r\n    idx.highlighted = false;\r\n    idx.sorted = true;\r\n  });\r\n\r\n  return globalSnapshot;\r\n};\r\n\r\nconst quickSortHelper = (arr, start, end) => {\r\n  if (start >= end) {\r\n    return;\r\n  }\r\n\r\n  // Get pivot point\r\n  const index = partition(arr, start, end);\r\n\r\n  // Recursivley call helper function on both sides of the pivot\r\n  quickSortHelper(globalArr, start, index - 1);\r\n  quickSortHelper(globalArr, index + 1, end);\r\n};\r\n\r\nconst partition = (arr, start, end) => {\r\n  let pivotValue = arr[end].value;\r\n  let pivotIndex = start;\r\n\r\n  // Move values < pivot to left of pivot, and values > pivot to right of pivot\r\n  for (let i = start; i < end; i++) {\r\n    highlightIdx(arr, i);\r\n    highlightIdx(arr, pivotIndex);\r\n    if (arr[i].value < pivotValue) {\r\n      swap(arr, i, pivotIndex);\r\n      globalArr = arr;\r\n      globalSnapshot.push([...arr]);\r\n      clearIdx(arr, pivotIndex);\r\n      clearIdx(arr, i);\r\n      pivotIndex++;\r\n    }\r\n    globalSnapshot.push([...arr]);\r\n    clearIdx(arr, pivotIndex);\r\n    clearIdx(arr, i);\r\n  }\r\n\r\n  swap(arr, pivotIndex, end);\r\n  globalArr = arr;\r\n  globalSnapshot.push([...arr]);\r\n\r\n  return pivotIndex;\r\n};\r\n\r\nexport default quickSort;\r\n"]},"metadata":{},"sourceType":"module"}